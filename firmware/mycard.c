#include "ch32v003fun.h"
#include <stdio.h>
#include "ws2812b_dma_spi_led_driver.h"


uint32_t count;
uint16_t lastnum=123;


uint8_t letters[128][6] = {
{0x00,0x00,0x00,0x00,0x00,0x00},   //   0x 0 0
{0x00,0x64,0x18,0x04,0x64,0x18},   //  0x 1 1 Left arrow
{0x00,0x3c,0x40,0x40,0x20,0x7c},   //  0x 2 2
{0x00,0x0c,0x30,0x40,0x30,0x0c},   //  0x 3 3 Right Arrow
{0x00,0x3c,0x40,0x30,0x40,0x3c},   //  0x 4 4
{0x00,0x00,0x3e,0x1c,0x08,0x00},   //  0x 5 5 Therefore
{0x00,0x04,0x1e,0x1f,0x1e,0x04},   //  0x 6 6 
{0x00,0x10,0x3c,0x7c,0x3c,0x10},   //  0x 7 7 Phone
{0x00,0x20,0x40,0x3e,0x01,0x02},   //  0x 8 8  Tick
{0x00,0x22,0x14,0x08,0x14,0x22},   //   0x 9 9
{0x00,0x00,0x38,0x28,0x38,0x00},   //   0x a 10
{0x00,0x00,0x10,0x38,0x10,0x00},   //  0x b 11 Music
{0x00,0x00,0x00,0x10,0x00,0x00},   // 0x c 12
{0x00,0x08,0x78,0x08,0x00,0x00},   //   0x d 13
{0x00,0x00,0x15,0x15,0x0a,0x00},   //  0x e 14
{0x00,0x7f,0x7f,0x09,0x09,0x01},   //  0x f 15 Music 
{0x00,0x10,0x20,0x7f,0x01,0x01},   //  0x10 16
{0x00,0x04,0x04,0x00,0x01,0x1f},   //  0x11 17
{0x00,0x00,0x19,0x15,0x12,0x00},   //  0x12 18
{0x00,0x40,0x60,0x50,0x48,0x44},   //  0x13 19
{0x00,0x06,0x09,0x09,0x06,0x00},   //  0x14 20
{0x00,0x0f,0x02,0x01,0x01,0x00},   //  0x15 21 Phi 
{0x00,0x00,0x01,0x1f,0x01,0x00},   //  0x16 22
{0x00,0x44,0x44,0x4a,0x4a,0x51},   //  0x17 23
{0x00,0x14,0x74,0x1c,0x17,0x14},   //  0x18 24
{0x00,0x51,0x4a,0x4a,0x44,0x44},   //  0x19 25
{0x00,0x00,0x00,0x04,0x04,0x04},   //   0x1a 26
{0x00,0x00,0x7c,0x54,0x54,0x44},   //  0x1b 27
{0x00,0x08,0x08,0x2a,0x1c,0x08},   //   0x1c 28 clock
{0x00,0x7c,0x00,0x7c,0x44,0x7c},   //   0x1d 29 alpha 
{0x00,0x04,0x02,0x7f,0x02,0x04},   //   0x1e 30 
{0x00,0x10,0x20,0x7f,0x20,0x10},   //   0x1f 31
{0x00,0x00,0x00,0x00,0x00,0x00},   //   0x20 32
{0x00,0x00,0x00,0x6f,0x00,0x00},   // ! 0x21 33
{0x00,0x00,0x07,0x00,0x07,0x00},   // " 0x22 34
{0x00,0x14,0x7f,0x14,0x7f,0x14},   // // 0x23 35
{0x00,0x00,0x07,0x04,0x1e,0x00},   // $ 0x24 36
{0x00,0x23,0x13,0x08,0x64,0x62},   // % 0x25 37
{0x00,0x36,0x49,0x56,0x20,0x50},   // & 0x26 38
{0x00,0x00,0x00,0x07,0x00,0x00},   // ' 0x27 39
{0x00,0x00,0x1c,0x22,0x41,0x00},   // ( 0x28 40
{0x00,0x00,0x41,0x22,0x1c,0x00},   // ) 0x29 41
{0x00,0x14,0x08,0x3e,0x08,0x14},   // * 0x2a 42
{0x00,0x08,0x08,0x3e,0x08,0x08},   // + 0x2b 43
{0x00,0x00,0x50,0x30,0x00,0x00},   // , 0x2c 44
{0x00,0x08,0x08,0x08,0x08,0x08},   // - 0x2d 45
{0x00,0x00,0x60,0x60,0x00,0x00},   // . 0x2e 46
{0x00,0x20,0x10,0x08,0x04,0x02},   // / 0x2f 47
{0x00,0x3e,0x51,0x49,0x45,0x3e},   // 0 0x30 48
{0x00,0x00,0x42,0x7f,0x40,0x00},   // 1 0x31 49
{0x00,0x42,0x61,0x51,0x49,0x46},   // 2 0x32 50
{0x00,0x21,0x41,0x45,0x4b,0x31},   // 3 0x33 51
{0x00,0x18,0x14,0x12,0x7f,0x10},   // 4 0x34 52
{0x00,0x27,0x45,0x45,0x45,0x39},   // 5 0x35 53
{0x00,0x3c,0x4a,0x49,0x49,0x30},   // 6 0x36 54
{0x00,0x01,0x71,0x09,0x05,0x03},   // 7 0x37 55
{0x00,0x36,0x49,0x49,0x49,0x36},   // 8 0x38 56
{0x00,0x06,0x49,0x49,0x29,0x1e},   // 9 0x39 57
{0x00,0x00,0x36,0x36,0x00,0x00},   // : 0x3a 58
{0x00,0x00,0x56,0x36,0x00,0x00},   // ; 0x3b 59
{0x00,0x08,0x14,0x22,0x41,0x00},   // < 0x3c 60
{0x00,0x14,0x14,0x14,0x14,0x14},   // = 0x3d 61
{0x00,0x00,0x41,0x22,0x14,0x08},   // > 0x3e 62
{0x00,0x02,0x01,0x51,0x09,0x06},   // ? 0x3f 63
{0x00,0x3e,0x41,0x5d,0x49,0x4e},   // @ 0x40 64
{0x00,0x7e,0x09,0x09,0x09,0x7e},   // A 0x41 65
{0x00,0x7f,0x49,0x49,0x49,0x36},   // B 0x42 66
{0x00,0x3e,0x41,0x41,0x41,0x22},   // C 0x43 67
{0x00,0x7f,0x41,0x41,0x41,0x3e},   // D 0x44 68
{0x00,0x7f,0x49,0x49,0x49,0x41},   // E 0x45 69
{0x00,0x7f,0x09,0x09,0x09,0x01},   // F 0x46 70
{0x00,0x3e,0x41,0x49,0x49,0x7a},   // G 0x47 71
{0x00,0x7f,0x08,0x08,0x08,0x7f},   // H 0x48 72
{0x00,0x00,0x41,0x7f,0x41,0x00},   // I 0x49 73
{0x00,0x20,0x40,0x41,0x3f,0x01},   // J 0x4a 74
{0x00,0x7f,0x08,0x14,0x22,0x41},   // K 0x4b 75
{0x00,0x7f,0x40,0x40,0x40,0x40},   // L 0x4c 76
{0x00,0x7f,0x02,0x0c,0x02,0x7f},   // M 0x4d 77
{0x00,0x7f,0x04,0x08,0x10,0x7f},   // N 0x4e 78
{0x00,0x3e,0x41,0x41,0x41,0x3e},   // O 0x4f 79
{0x00,0x7f,0x09,0x09,0x09,0x06},   // P 0x50 80
{0x00,0x3e,0x41,0x51,0x21,0x5e},   // Q 0x51 81
{0x00,0x7f,0x09,0x19,0x29,0x46},   // R 0x52 82
{0x00,0x46,0x49,0x49,0x49,0x31},   // S 0x53 83
{0x00,0x01,0x01,0x7f,0x01,0x01},   // T 0x54 84
{0x00,0x3f,0x40,0x40,0x40,0x3f},   // U 0x55 85
{0x00,0x0f,0x30,0x40,0x30,0x0f},   // V 0x56 86
{0x00,0x3f,0x40,0x30,0x40,0x3f},   // W 0x57 87
{0x00,0x63,0x14,0x08,0x14,0x63},   // X 0x58 88
{0x00,0x07,0x08,0x70,0x08,0x07},   // Y 0x59 89
{0x00,0x61,0x51,0x49,0x45,0x43},   // Z 0x5a 90
{0x00,0x3c,0x4a,0x49,0x29,0x1e},   // { 0x5b 91
{0x00,0x02,0x04,0x08,0x10,0x20},   // \ 0x5c 92
{0x00,0x00,0x41,0x7f,0x00,0x00},   // } 0x5d 93
{0x00,0x04,0x02,0x01,0x02,0x04},   // ^ 0x5e 94
{0x00,0x40,0x40,0x40,0x40,0x40},   // _ 0x5f 95
{0x00,0x00,0x00,0x03,0x04,0x00},   // ` 0x60 96
{0x00,0x20,0x54,0x54,0x54,0x78},   // a 0x61 97
{0x00,0x7f,0x48,0x44,0x44,0x38},   // b 0x62 98
{0x00,0x38,0x44,0x44,0x44,0x20},   // c 0x63 99
{0x00,0x38,0x44,0x44,0x48,0x7f},   // d 0x64 100
{0x00,0x38,0x54,0x54,0x54,0x18},   // e 0x65 101
{0x00,0x08,0x7e,0x09,0x01,0x02},   // f 0x66 102
{0x00,0x0c,0x52,0x52,0x52,0x3e},   // g 0x67 103
{0x00,0x7f,0x08,0x04,0x04,0x78},   // h 0x68 104
{0x00,0x00,0x44,0x7d,0x40,0x00},   // i 0x69 105
{0x00,0x20,0x40,0x44,0x3d,0x00},   // j 0x6a 106
{0x00,0x00,0x7f,0x10,0x28,0x44},   // k 0x6b 107
{0x00,0x00,0x41,0x7f,0x40,0x00},   // l 0x6c 108
{0x00,0x7c,0x04,0x18,0x04,0x78},   // m 0x6d 109
{0x00,0x7c,0x08,0x04,0x04,0x78},   // n 0x6e 110
{0x00,0x38,0x44,0x44,0x44,0x38},   // o 0x6f 111
{0x00,0x7c,0x14,0x14,0x14,0x08},   // p 0x70 112
{0x00,0x08,0x14,0x14,0x18,0x7c},   // q 0x71 113
{0x00,0x7c,0x08,0x04,0x04,0x08},   // r 0x72 114
{0x00,0x48,0x54,0x54,0x54,0x20},   // s 0x73 115
{0x00,0x04,0x3f,0x44,0x40,0x20},   // t 0x74 116
{0x00,0x3c,0x40,0x40,0x20,0x7c},   // u 0x75 117
{0x00,0x1c,0x20,0x40,0x20,0x1c},   // v 0x76 118
{0x00,0x3c,0x40,0x30,0x40,0x3c},   // w 0x77 119
{0x00,0x44,0x28,0x10,0x28,0x44},   // x 0x78 120
{0x00,0x0c,0x50,0x50,0x50,0x3c},   // y 0x79 121
{0x00,0x44,0x64,0x54,0x4c,0x44},   // z 0x7a 122
{0x00,0x00,0x08,0x36,0x41,0x41},   // { 0x7b 123
{0x00,0x00,0x00,0x7f,0x00,0x00},   // | 0x7c 124
{0x00,0x41,0x41,0x36,0x08,0x00},   // } 0x7d 125
{0x00,0x04,0x02,0x04,0x08,0x04},   // ~ 0x7e 126
{0x00,0x7f,0x6b,0x6b,0x6b,0x7f}    //  0x7f 127};
};
void showchar(uint8_t);



/* some bit definitions for systick regs */
#define SYSTICK_SR_CNTIF (1<<0)
#define SYSTICK_CTLR_STE (1<<0)
#define SYSTICK_CTLR_STIE (1<<1)
#define SYSTICK_CTLR_STCLK (1<<2)
#define SYSTICK_CTLR_STRE (1<<3)
#define SYSTICK_CTLR_SWIE (1<<31)


volatile uint32_t systick_cnt;
volatile uint32_t cnts[40];
volatile uint16_t cmd=0;
volatile uint8_t bits=0, switch_wake=0;





// From https://github.com/Blakesands/CH32V003/blob/main/GD_WS2812_DRIVER.h
// Send a single bit using the GD pinwiggle protocol.
void LED_SendBit(uint8_t bit)
{
    if (bit) {
    //// Send a 1 bit
        GPIOD->BSHR |= 1 << 6; // put pin D6 high and wait for 800nS
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");
        GPIOD->BCR = 1 << 6; // put pin D6 low and exit, 400nS is taken up by other functions
        return;
        }
//    else {
        // Send a 0 bit
        GPIOD->BSHR |= 1 << 6; // put pin D6 high and wait for 400nS
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");
        GPIOD->BCR |= 1 << 6; // put pin D6 low and wait for 400nS, 400nS is taken up by other functions
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
            __asm__("nop");__asm__("nop");__asm__("nop");__asm__("nop");
//    }
}

// Send a single colour for a single LED
//WS2812B LEDs want 24 bits per led in the string
void LED_SendColour(uint8_t red, uint8_t green, uint8_t blue)
{
    // Send the green component first (MSB)
    for (int i = 7; i >= 0; i--) {
        LED_SendBit((green >> i) & 1);
    }
    // Send the red component next
    for (int i = 7; i >= 0; i--) {
        LED_SendBit((red >> i) & 1);
    }
    // Send the blue component last (LSB)
    for (int i = 7; i >= 0; i--) {
        LED_SendBit((blue >> i) & 1);
    }
}


void blink(){
	for(int i=0;i<2;i++){
	    GPIOC->BSHR |= 0b11111111; // set all
		Delay_Ms(500);
	    GPIOC->BCR |= 0b11111111; // clear all
		Delay_Ms(500);
	}
}

void blinkbit(uint8_t bit){
	for(int i=0;i<2;i++){
	    GPIOC->BCR |= 255; // clear all
		Delay_Ms(200);
	    GPIOC->BSHR |= 1<<bit; // set all
		Delay_Ms(200);
	}
}

void section1(){
			GPIOD->BCR |= 0b1100; GPIOD->BSHR |= 0b1000;
}
void section2(){
			GPIOD->BCR |= 0b1100; GPIOD->BSHR |= 0b0100;
}
void sectionoff(){
			GPIOC->BCR |= 0b11111111; // clear all L1-L7 as well
			GPIOD->BCR |= 0b1100;
}



void adc_init( void );
uint16_t adc_get( void );

void enableAutoWakeup();
void writeString(char * s);
void fadeRGB();

void scrollUpDown(uint8_t);
void fadeAutoRGB();

void batmon(){
	section1();
	GPIOC->BCR = 0b11111111; // clear all
	GPIOC->BSHR |= (1<<((2*adc_get()-6600)/150))-1 ; // set new
	//printf("%d\n",(2*adc_get())/1000);
	Delay_Ms(1000);
	section2();
	Delay_Ms(200);
	sectionoff();
}
void fadeheart(uint8_t times){
	sectionoff();
	// Enable GPIOC, GPIOD and TIM1
	RCC->APB2PCENR |= 	RCC_APB2Periph_TIM1;
	
	// Reset TIM1 to init all regs
	RCC->APB2PRSTR |= RCC_APB2Periph_TIM1;
	RCC->APB2PRSTR &= ~RCC_APB2Periph_TIM1;
	
	// CTLR1: default is up, events generated, edge align
	// SMCFGR: default clk input is CK_INT
	
	// Prescaler 
	TIM1->PSC = 0x0000;	
	// Auto Reload - sets period
	TIM1->ATRLR = 255;	
	// Reload immediately
	TIM1->SWEVGR |= TIM_UG;
	

	TIM1->CTLR1 |= TIM_ARPE;

	// Enable CH1 output, positive pol
	TIM1->CCER |= TIM_CC1E;
	
	// CH1 Mode is output, PWM1 (CC1S = 00, OC1M = 110)
	TIM1->CHCTLR1 |= TIM_OC1M_2 | TIM_OC1M_1 | TIM_OC1PE;
	// Set the Capture Compare Register value to 50% initially
	TIM1->CH1CVR = 1;
	// Enable TIM1 outputs
	TIM1->BDTR |= TIM_MOE;
	// Enable TIM1
	TIM1->CTLR1 |= TIM_CEN;
	funPinMode( PD2, GPIO_CFGLR_OUT_10Mhz_AF_PP );	//enable alt func
	GPIOC->BSHR |= 0b11100 ; // set new
	for(int n=0;n<times;n++){
		for(int x=1;x<255;x++){
			TIM1->CH1CVR = x;
			Delay_Ms(50);
		}
		for(int x=255;x>0;x--){
			TIM1->CH1CVR = x;
			Delay_Ms(50);
		}
	}
	// Stop TIM1
	TIM1->CTLR1 &= ~TIM_CEN;
	funPinMode( PD2, GPIO_CFGLR_OUT_10Mhz_PP );	//back to push pull
}



void EXTI7_0_IRQHandler( void ) __attribute__((interrupt));
void EXTI7_0_IRQHandler( void ) 
{
	for(int z=0;z<2;z++){
		scrollUpDown(2);
		scrollUpDown(1);
	}
	
	//fadeAutoRGB();						
	for(int z=0;z<10;z++){
		TIM2->CNT = 0;
		writeString("HELLO");
	}			
	sectionoff();
	//fadeRGB();

	EXTI->INTFR = EXTI_Line0;
}

int main()
{
	uint8_t wakeups=0;
	SystemInit();

	SetupDebugPrintf();
	SysTick->CTLR = 0;
	SysTick->CNT = 0;
	/* Enable SysTick counter, IRQ, HCLK/1 */
	SysTick->CTLR = SYSTICK_CTLR_STE | SYSTICK_CTLR_STIE |
					SYSTICK_CTLR_STCLK;
	// Enable GPIOs
	RCC->APB2PCENR = RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO;

	
	// Enable TIM2
	RCC->APB1PCENR |= RCC_APB1Periph_TIM2;
	// Reset TIM2 to init all regs
	RCC->APB1PRSTR |= RCC_APB1Periph_TIM2;
	RCC->APB1PRSTR &= ~RCC_APB1Periph_TIM2;
	// SMCFGR: default clk input is CK_INT
	// set TIM2 clock prescaler divider 
	TIM2->PSC = 0xFFFF;
	// Enable TIM2
	TIM2->CTLR1 |= TIM_CEN;
	

	// GPIO D3,D4 for input pin change.
	//funPinMode( PD3, GPIO_CFGLR_IN_FLOAT );
	funPinMode( PD4, GPIO_CFGLR_IN_FLOAT );

	funPinMode( PD0,  GPIO_CFGLR_IN_PUPD ); //switch

	funDigitalWrite( PA2, FUN_HIGH );
	funDigitalWrite( PD0, FUN_HIGH );

	//funPinMode( PD6,  GPIO_CFGLR_OUT_10Mhz_PP ); //rgb

	funPinMode( PC0,  GPIO_CFGLR_OUT_10Mhz_PP );
	funPinMode( PC1,  GPIO_CFGLR_OUT_10Mhz_PP );
	funPinMode( PC2,  GPIO_CFGLR_OUT_10Mhz_PP );
	funPinMode( PC3,  GPIO_CFGLR_OUT_10Mhz_PP );
	funPinMode( PC4,  GPIO_CFGLR_OUT_10Mhz_PP );
	funPinMode( PC5,  GPIO_CFGLR_OUT_10Mhz_PP );
	funPinMode( PC6,  GPIO_CFGLR_OUT_10Mhz_PP );
	funPinMode( PC7,  GPIO_CFGLR_OUT_10Mhz_PP );

	// OUTPUT TRANSISTORS
	funPinMode( PD2, GPIO_CFGLR_OUT_10Mhz_PP );	
	funPinMode( PD3, GPIO_CFGLR_OUT_10Mhz_PP );	
	funDigitalWrite( PD2, FUN_LOW );
	funDigitalWrite( PD3, FUN_LOW );



	asm volatile(
#if __GNUC__ > 10
		".option arch, +zicsr\n"
#endif
 		"addi t1, x0, 3\n"
		"csrrw x0, 0x804, t1\n"
		 : : :  "t1" );

	// Configure the D0 IO as an interrupt.
	AFIO->EXTICR = AFIO_EXTICR_EXTI0_PD;
	EXTI->INTENR = EXTI_INTENR_MR0; // Enable EXT3
	EXTI->RTENR = EXTI_FTENR_TR0;  // Falling edge trigger
	// enable interrupt
	NVIC_EnableIRQ( EXTI7_0_IRQn );
	//NVIC_DisableIRQ(EXTI7_0_IRQn);

	// select standby on power-down
	PWR->CTLR |= PWR_CTLR_PDDS;


	funPinMode( PD5,  GPIO_CFGLR_IN_PUPD ); //REED switch
	funDigitalWrite(PD5, FUN_HIGH); //pullup reed switch


	enableAutoWakeup();
	
	//adc_init(); //vdd monitoring
	while(1){

		if (wakeups%5==0)
			fadeheart(1);

		wakeups++;
		//batmon();

		NVIC_EnableIRQ( EXTI7_0_IRQn );
		// peripheral interrupt controller send to deep sleep
		sectionoff();
		PFIC->SCTLR |= (1 << 2);
		//printf("entering sleep loop \n");
		switch_wake=0; // reset switch wake flag.
		__WFE();
		//printf("\nALIVEEE\n");
		SystemInit();
		NVIC_DisableIRQ(EXTI7_0_IRQn);

	}


}


void adc_init( void )
{
	// ADCCLK = 24 MHz => RCC_ADCPRE = 0: divide by 2
	RCC->CFGR0 &= ~(0x1F<<11);
	
	// Enable  ADC
	RCC->APB2PCENR |=  RCC_APB2Periph_ADC1;
	
	// Reset the ADC to init all regs
	RCC->APB2PRSTR |= RCC_APB2Periph_ADC1;
	RCC->APB2PRSTR &= ~RCC_APB2Periph_ADC1;
	
	// Set up single conversion on chl 5(Vdd)
	ADC1->RSQR1 = 0;
	ADC1->RSQR2 = 0;
	ADC1->RSQR3 = 8;	// 0-9 for 8 ext inputs and two internals
	
	// set sampling time for chl 7
	ADC1->SAMPTR2 &= ~(ADC_SMP0<<(3*7));
	ADC1->SAMPTR2 |= 7<<(3*7);	// 0:7 => 3/9/15/30/43/57/73/241 cycles
		
	// turn on ADC and set rule group to sw trig
	ADC1->CTLR2 |= ADC_ADON | ADC_EXTSEL;
	
	// Reset calibration
	ADC1->CTLR2 |= ADC_RSTCAL;
	while(ADC1->CTLR2 & ADC_RSTCAL);
	
	// Calibrate
	ADC1->CTLR2 |= ADC_CAL;
	while(ADC1->CTLR2 & ADC_CAL);
	
	// should be ready for SW conversion now
}

/*
 * start conversion, wait and return result
 */
uint16_t adc_get( void )
{
	// start sw conversion (auto clears)
	ADC1->CTLR2 |= ADC_SWSTART;
	// wait for conversion complete
	while(!(ADC1->STATR & ADC_EOC));
	
	// get result
	return ((uint32_t)1200 * 1023 / ADC1->RDATAR); //return in mV
}


void enableAutoWakeup(){
	// enable power interface module clock
	RCC->APB1PCENR |= RCC_APB1Periph_PWR;

	// enable low speed oscillator (LSI)
	RCC->RSTSCKR |= RCC_LSION;
	while ((RCC->RSTSCKR & RCC_LSIRDY) == 0) {}

	// enable AutoWakeUp event
	EXTI->EVENR |= EXTI_Line9;
	EXTI->FTENR |= EXTI_Line9;

	// configure AWU prescaler
	PWR->AWUPSC |= PWR_AWU_Prescaler_61440;

	// configure AWU window comparison value
	PWR->AWUWR &= ~0x3f;
	PWR->AWUWR |= 63;

	// enable AWU
	PWR->AWUCSR |= (1 << 1);

}

void fadeRGB(){
	return;
		for(int y=0;y<2;y++){

			for(int x=0;x<100;x++){
				LED_SendColour(x,100-x,x);
				Delay_Ms(30);
			}
			for(int x=100;x>0;x--){
				LED_SendColour(x,100-x,x);
				Delay_Ms(30);
			}
		}
		for(int x=100;x>=0;x--){
			LED_SendColour(0,x,0);
			Delay_Ms(50);
		}

}

unsigned char reverse(unsigned char b) {
   b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
   b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
   b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
   return b;
}

#define POV_DEL 12
void showchar(uint8_t c){
  uint8_t x;
  for(x=0;x<6;x++)
   {
    GPIOC->BCR = 0b11111111; // clear all
    GPIOC->BSHR |= reverse( (letters[c][x]<<1)&0xFF) ; // set new
    Delay_Ms(POV_DEL);
   }
    GPIOC->BCR = 0b11111111; // clear all
}

void writeString(char * s){
	while( (((GPIOD->INDR)>>5)&1) && TIM2->CNT<1000 ); // no contact. high
	while( !(((GPIOD->INDR)>>5)&1) && TIM2->CNT<1000 ); //contact. low
	while( (((GPIOD->INDR)>>5)&1) && TIM2->CNT<1000 ); // no contact. high
    Delay_Ms(POV_DEL*2);
	GPIOD->BCR |= 0b1100; GPIOD->BSHR |= 0b1000;
	while(*s != '\0'){
		showchar(*s);
		s++;
	}
}


void scrollUpDown(uint8_t section){
		if(section==1)
			section1();
		else 
			section2();


		for(int x=0;x<8;x++)
		{
			GPIOC->BCR |= 0b11111111; // clear all
			GPIOC->BSHR |= (1<<x); // set new
			Delay_Ms(200);
		}
		for(int x=8;x>0;x--)
		{
			GPIOC->BCR |= 0b11111111; // clear all
			GPIOC->BSHR |= (1<<(x-1)); // set new
			Delay_Ms(200);
		}
		sectionoff();
}

void fadeAutoRGB(){
	section2();
	GPIOC->BSHR |= 128+1; // set new
	Delay_Ms(40000);
	sectionoff();
}
